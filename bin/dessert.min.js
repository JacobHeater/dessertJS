(function () {
    "use strict";

    define("dessert.interfaces", dessertInterfacesModule);

    /**
     * The require entry point for the dessert.interfaces module.
     * 
     * @returns {Object} The dependencies hash table.
     */
    function dessertInterfacesModule() {
        var interfaces = {
            IDataBindingProvider: IDataBindingProvider
        };

        return interfaces;
    }

    /**
     * An interface that describes a custom data binding tool that can be used
     * for databinding in the dessert framework.
     * 
     * @param {Object} implementation The object that contains the interface implementation
     */
    function IDataBindingProvider(implementation) {
        this.bindTemplateToData = function () {
            throw new NotImplementedError("IDataBindingProvider", "bindTemplateToData");
        };

        if (typeof implementation === "object") {
            Object
                .keys(implementation)
                .forEach(function(key) {
                    if (this.hasOwnProperty(key)) {
                        this[key] = implementation[key];
                    }
                }.bind(this));
        } else {
            throw new InvalidArgumentError("implementation", "object");
        }
    }
    
    function NotImplementedError(interfaceName, methodName) {
        var message = 'Method "' + methodName + '" not implemented in interface "' + interfaceName + '"!';
        
        Error.call(this);

        this.message = message;

        return this;
    }

    NotImplementedError.prototype = Object.create(Error.prototype);
    NotImplementedError.prototype.constructor = NotImplementedError;
})();
/**
 * @file Defines the dessertJS Controller prototype.
 * @author Jacob Heater
 */
(function () {

    "use strict";

    define("dessert.controller", ["dessert.interfaces"], function dessertControllerModule(interfaces) {

        /**
         * The dessertJS controller is what drives the logic of the modules. Modules are
         * collections of controllers. The controllers are responsible for driving their
         * respective functionality.
         * 
         * @class
         * 
         * @param {String}    name          The name of the controller. This name should match up with
         *                                  with the [dsrt-controller] on the DOM element. When the
         *                                  dessertJS parser parses the modules, it will match up controllers
         *                                  by name, which will be the value of the [dsrt-controller] attribute.
         * @param {Object}   $controller    The jQuery instance that correlates with this dessertJS controller instance.
         * @param {Function} implementation The controller constructor that will be called when the view initialization has
         *                                  completed.
         */
        function Controller(name, module, app, $controller, implementation) {
            var _readyCallbacks = [];
            var _isControllerAsync = false;

            this.name = name || "";
            this.module = module;
            this.app = app;
            this.$controller = $controller;
            this.onInit = function emptyInitFunction() {};
            this.constructor = implementation || function emptyControllerConstructor() {};
            this.constructor.prototype.scope = function emptyScopeFunction() {};
            this.constructor.prototype.destroy = function emptyDestroyFunction() {};
            this.constructor.prototype.init = function emptyControllerInit() {};
            this.constructor.prototype.isAsync = false;
            this.constructor.prototype.initData = function () {
                return {};
            };
            Object.defineProperties(this.constructor.prototype, {
                ready: {
                    writable: false,
                    value: function (callback) {
                        if (typeof callback === "function") {
                            _readyCallbacks.push(callback);
                        }
                        return this;
                    }
                },
                notify: {
                    writable: false,
                    value: function controllerReadyNotify() {
                        var that = this;

                        _readyCallbacks.forEach(function(callback) {
                            callback.call(that, that);
                        });

                        _readyCallbacks.length = 0;
                    }
                },
                dataBind: {
                    writable: false,
                    value: function (view) {
                        if (app && app.providers && app.providers.IDataBindingProvider instanceof interfaces.IDataBindingProvider) {
                            var output = app.providers.IDataBindingProvider.bindTemplateToData(view, this.initData());
                            return output;
                        }
                        return view;
                    }
                },
                isAsync: {
                    get: function() {
                        return _isControllerAsync;
                    },
                    set: function(value) {
                        if (typeof value === "boolean") {
                            _isControllerAsync = value;
                        }
                    }
                }
            });
            this.instance = null;
        };
        return Controller;
    });
})();
/**
 * @file A module that exposes common methods that are shared througouht the dessertJS framework. 
 * This common module contains mostly helper methods and common variables.
 * @author Jacob Heater 
 */
(function() {

    "use strict";

    define("dessert.common", [], dessertCommonModule);

    /**
     * RequireJS entry point.
     * 
     * @returns {Object} An object that exposes common dessertJS functionality.
     */
    function dessertCommonModule() {

        /**
         * Defines a read only property on the given object with the given value.
         * 
         * @param {Object} obj The object to add the read only property to.
         * @param {String} propertyName The name of the read only property.
         * @param {any} propertyValue The value of the read only property.
         */
        function defineReadOnlyProperty(obj, propertyName, propertyValue) {
            Object.defineProperty(obj, propertyName, {
                writable: false,
                value: propertyValue
            });
        }

        /**
         * Defines a set of read only properties on the given object.
         * 
         * @param {Object} obj The object to add the read only properties to.
         * @param {Object} dictionary The properties dictionary that contains the name of the property and the value.
         */
        function defineReadOnlyProperties(obj, dictionary) {
            if (typeof dictionary === "object") {
                Object
                .keys(dictionary)
                .forEach(function propsDictionaryKeysForEach(key) {
                    defineReadOnlyProperty(obj, key, dictionary[key]);
                });
            }
        }

        /**
         * Attributes that are used to describe html entities.
         */
        var attrs = {};

        defineReadOnlyProperties(attrs, {
            app: 'dsrt-app',
            module: 'dsrt-module',
            controller: 'dsrt-controller',
            view: 'dsrt-view',
            component: 'dsrt-component',
            control: 'dsrt-control',
            controlGroup: 'dsrt-control-group',
            model: 'dsrt-model',
            mask: 'dsrt-mask',
            src: 'dsrt-src',
            rpt: 'dsrt-repeat',
            page: 'dsrt-page',
            id: "id"
        });

        /**
         * Selectors that are used in conjunction with the above attributes
         * to find matching dessertJS DOM elements.
         */
        var selectors = {};

        defineReadOnlyProperties(selectors, {
            app: '[$app]'.replace('$app', attrs.app),
            module: '[$module]'.replace('$module', attrs.module),
            controller: '[$controller]'.replace('$controller', attrs.controller),
            view: '[$view]'.replace('$view', attrs.view),
            component: '[$component]'.replace("$component", attrs.component),
            control: '[$control]'.replace('$control', attrs.control),
            controlGroup: '[$controlGroup]'.replace('$controlGroup', attrs.controlGroup),
            model: '[$model]'.replace('$model', attrs.model),
            mask: '[$mask]'.replace('$mask', attrs.mask),
            src: '[$src]'.replace('$src', attrs.src),
            rpt: '[$rpt]'.replace('$rpt', attrs.rpt),
            page: '[$page]'.replace('$page', attrs.page),
            id: "[$id]".replace("$id", attrs.id)
        });

        /**
         * A collection of regular expressions to be shared commonly.
         */
        var regex = {};

        /**
         * Defines the different path types in dessertJS.
         */
        var pathTypes = {};

        defineReadOnlyProperties(pathTypes, {
            src: 1,
            templates: 2
        });

        /**
         * A common utilities library for dessertJS.
         */
        var utils = {};

        defineReadOnlyProperties(utils, {
            emptyString: "",
            noop: function() {},
            /**
             * Gets the outer html of the given jQuery element. 
             * @param {Object} $context The jQuery instance to get the outer html of.
             */
            getOuterHtml: function($context) {
                var elem = $context;
                var wrapped = elem.wrap('<div />');
                var html = wrapped.parent().html();
                elem.unwrap('<div />');
                return html;
            },

            /**
             * Cleans the given path of any illegal characters.
             * 
             * @param {String} path The path to clean.
             * @returns {String} The cleaned path.
             */
            cleanPath: function(path) {
                var protocol = /[a-z]+:\/\//gmi;
                var duplFwdSlash = /\/\//gmi;
                var pathSplit = path.split(protocol);
                var pathLeft = "";
                var pathRight = "";
                if (pathSplit.length > 1) {
                    pathLeft = pathSplit[0];
                    pathRight = pathSplit[1];
                    pathRight = pathRight.replace(duplFwdSlash, '/');
                } else {
                    pathLeft = pathSplit[0];
                    pathLeft = pathLeft.replace(duplFwdSlash, '/');
                }
                return pathLeft + pathRight;
            },
            /**
             * Parses a query string from the given path using a ? separator.
             * 
             * @param {String} path The path to parse.
             * @returns {Object} A hash table of key value pairs.
             */
            parseQueryString: function(path) {
                var obj = {};
                if (path && path.indexOf("?") > -1) {
                    var pathSplit = path.split("?");
                    var qStr = pathSplit[1];
                    var pairs = qStr.split("&");
                    pairs.forEach(function(p) {
                        var kvp = p.split("=");
                        var key = kvp[0];
                        var value = kvp[1];
                        try {
                            value = JSON.parse(value);
                        } catch (err) {
                            value = kvp[1];
                        }
                        obj[key] = value;
                    });
                }
                return obj;
            },
            /**
             * Cleans the query string from the path using the ? separator.
             * 
             * @param {String} path The path to clean.
             * @returns {String} The cleaned path.
             */
            cleanQueryString: function(path) {
                return path ? path.split("?")[0] : path;
            },

            /**
             * Gets the attributes from a jQuery object and returns them as a map.
             * 
             * @param {Object} elem The jQuery object to get the attributes of.
             * @param {Array.<string>} exclude The list of attrs to exclude.
             * @returns {Object} The attribute map.
             */
            getElementAttrs: function(elem, exclude) {
                var attrMap = {};
                exclude = this.isArray(exclude) ? exclude : [];
                if (elem) {
                    var nativeElem = elem.get(0);
                    if (nativeElem) {
                        var nativeAttrs = nativeElem.attributes;
                        if (nativeAttrs.length) {
                            Object.keys(nativeAttrs).forEach(function(key) {
                                var attr = nativeAttrs[key];
                                if (typeof attr.nodeValue !== "undefined" && attr.nodeName && exclude.indexOf(attr.nodeName) === -1) {
                                    attrMap[attr.nodeName] = attr.nodeValue;
                                }
                            });
                        }
                    }
                }
                return attrMap;
            },

            /**
             * Determines if the given object is of typeof "object."
             * 
             * @param {Object} ref The object to check.
             * @returns {Boolean} True if is of type "object."
             */
            isObject: function(ref) {
                return typeof ref === "object";
            },

            /**
             * Determines if the given value is typeof "function".
             * 
             * @param {function} fn The object to check.
             * @returns {Boolean} True if is typeof "function".
             */
            isFunction: function(fn) {
                return typeof fn === "function";
            },

            /**
             * Determines if the given object is an array.
             * 
             * @param {Object} arr The object to inspect.
             * @returns {Boolean} True if it is an array.
             */
            isArray: function(arr) {
                return Array.isArray(arr);
            },

            /**
             * Determines if the given value is of type string.
             * 
             * @param {String} str The object to check the type of.
             * @returns {Boolean} True if the object is a string.
             */
            isString: function(str) {
                return typeof str === "string";
            },

            addReadOnlyProperty: function(obj, propName, value) {
                defineReadOnlyProperty(obj, propName, value);

                return this;
            },

            addReadOnlyProperties: function(obj, hash) {
                defineReadOnlyProperties(obj, hash);

                return this;
            },

            defer: function(action, args) {
                args = args && Array.isArray(args) ? args : [];
                if (this.isFunction(action)) {
                    setTimeout(function() {
                        action.apply(null, args);
                    }, 0);
                }
            }
        });

        return {
            attrs: attrs,
            selectors: selectors,
            regex: regex,
            utils: utils,
            pathTypes: pathTypes
        };
    }
})();
/**
 * @file Defines a dessertJS Module prototype.
 * @author Jacob Heater
 */
(function() {

    "use strict";

    define("dessert.module", [
            'dessert.controller',
            "dessert.common"
        ],
        function dessertModuleModule(Controller, $common) {

            var utils = $common.utils;

            /**
             * A Modules in dessertJS is the highest level element that can be on the page
             * besides the application scope. Each Module represents a scope in dessertJS,
             * and within each Module there can be several Controllers. Each Controller is a
             * scope. Modules are the top level scope where application logic can be grouped
             * together and reused. Modules encourage Controller reuse. This allows application
             * functionality not only to be grouped, but reused.
             * 
             * @class
             * 
             * @param {String} name The name of the module. This must match whatever the value
             * of the dsrt-module attribute value is on the element.
             * @param {Object} app The application scope of which the Module is a child of.
             * @param {Object} $module The jQuery instance that encapsulates the [dsrt-module] element.
             * @param {Object} globals The global variables that need to be shared among Modules.
             */
            function Module(name, app, $module, globals) {

                /**
                 * A cache of all of the controllers this Module is a parent to.
                 */
                var controllers = {};
                this.name = name || "";
                /**
                 * Bootstraps a new Controller singleton instance to be appended to the
                 * controllers cache.
                 * 
                 * @param {String} name The name of the controller to add to the Module.
                 * @param {Function} implementation The constrcutor for the controller.
                 * @returns {Object} The Controller instance.
                 */
                this.controller = function controller(name, implementation) {
                    controllers[name] = new Controller(name, this, app, undefined, implementation);
                    return controllers[name];
                };
                this.controllers = {
                    /**
                     * Gets a Controller instance from the controllers cache
                     * that belongs to this Module instance.
                     * 
                     * @param {String} name The name of the controller to retrieve.
                     * @returns {Object} The controller singleton.
                     */
                    get: function get(name) {
                        return controllers[name];
                    },
                    /**
                     * Removes the Controller singleton instance from the controllers
                     * cache.
                     * 
                     * @param {String} name The name of the controller to remove.
                     * @returns {Objet} The controllers namespace object for chaining.
                     */
                    remove: function remove(name) {
                        delete controllers[name];
                        return this;
                    },

                    /**
                     * Iterates over each controller in the module and
                     * fires the handler function.
                     * 
                     * @param {Function} handler The callback to fire over each controller.
                     * @returns {Object} The current instance of the Module.controllers object.
                     */
                    each: function(handler) {
                        if (utils.isFunction(handler)) {
                            Object
                                .keys(controllers)
                                .forEach(function(key) {
                                    handler.call(controllers[key], controllers[key]);
                                });
                        }

                        return this;
                    }
                };
                this.$module = $module;
                this.globals = globals || {};
                this.app = app;
                this.onInit = function emptyModuleOnInitFunction() {};
                /**
                 * Constructs a path to file for the Module based on the given
                 * pathType and path url.
                 * 
                 * @param {Number} pathType The pathTypes enum member value to lookup.
                 * @param {String} path The path to construct the string out of.
                 * @returns {String} The constructed path.
                 */
                this.getPath = function getPath(pathType, path) {
                    if (pathType === app.pathTypes.src) {
                        return {
                            path: app.src + path + '.html'
                        };
                    } else if (pathType === app.pathTypes.templates) {
                        return {
                            path: app.templates + path + '.html'
                        };
                    }
                };
                /**
                 * Creates a dsrt-src path from the given url using the
                 * pathTypes.src enum member value.
                 * 
                 * @param {String} path The path used to construct the absolute path.
                 * @returns {String} The fully constructed path.
                 */
                this.src = function src(path) {
                    return this.getPath(app.pathTypes.src, path);
                };
                /**
                 * Creates a template url from the given url using the
                 * pathTypes.templates enum member value.
                 * 
                 * @param {String} path The path used to construct the absolute path.
                 * @returns {String} The fully constructed path.
                 */
                this.template = function template(path) {
                    return this.getPath(app.pathTypes.templates, path);
                }
            };
            return Module;
        });


})();
(function() {

    "use strict";

    define("dessert.httphandlercache", [],function dessertHttpHandlerCacheModule() {

        /**
         * @class
         * A simple cache for storing HTTP handlers for different HTTP status codes.
         */
        function HttpHandlerCache() {
            /**
             * @class
             * @private
             * Represents an HTTP handler to handle different HTTP status codes throughout the application.
             * 
             * @param {String} name The name of the HTTP handler.
             * @param {Decimal|Number} The HTTP status code to handle.
             * @param {Function} handler The function that gets executed when the HTTP status code gets returned in the response.
             * @throws {InvalidArgumentException} Raises an exception when the arguments are not defined properly.
             */
            function HttpHandler(name, httpStatusCode, handler) {
                if (name && httpStatusCode && typeof handler === "function") {
                    /**
                     * The name of the HttpHandler instance.
                     */
                    this.name = name;
                    /**
                     * The HTTP status code of the HttpHandler instance.
                     */
                    this.statusCode = httpStatusCode;
                    /**
                     * The function that will be invoked when the HTTP status code is returned.
                     */
                    this.handler = handler;
                } else {
                    throw new Error("Invalid HTTP handler! Arguments must be defined as: {String} name, {Number} httpStatusCode, {Function} handler.");
                }
            }
            /**
             * @private
             * @memberOf HttpHandlerCache
             * 
             * A list of HttpHandler instance.
             */
            var handlers = [];
            /**
             * Gets all the handlers from the handler cache by the HTTP status code.
             * 
             * @param {Number|Decimal} code The HTTP status code to match.
             */
            this.getHandlersByStatusCode = function getHandlersByStatusCode(code) {
                return handlers.filter(function(h) {
                    return h.statusCode === code;
                });
            };
            /**
             * Gets all the handlers from the handler cache by the handler name.
             * 
             * @param {String} name The name of the HTTP status handler.
             */
            this.getHandlersByName = function getHandlersByName(name) {
                return handlers.filter(function(h) {
                    return h.name === name;
                });
            };
            /**
             * Adds a new HttpHandler instance to the HttpHandlerCache instance.
             * 
             * @param {String} name The name of the handler.
             * @param {Number|Decimal} The HTTP status code to listen for.
             * @param {Function} handler The function to invoke when the HTTP status code is returned.
             * @returns {Object} The current HttpHandlerCache instance for chaining.
             */
            this.addHandler = function addHandler(name, httpStatusCode, handler) {
                handlers.push(new HttpHandler(name, httpStatusCode, handler));
                return this;
            };
            /**
             * Removes an HttpHandler instance from the HttpHandlerCache instance by name.
             * 
             * @param {String} name The name of the handlers to remove.
             * @returns {Object} The current HttpHandlerCache instance for chaining.
             */
            this.removeHandler = function removeHandler(name) {
                var matchedHandlers = handlers.filter(function removeHandlerFilter(h) {
                    return h.name === name;
                });
                matchedHandlers.forEach(function removeHandlerForEach(h) {
                    var index = handlers.indexOf(h);
                    handlers.splice(index, 1);
                });
                return this;
            };
        }

        return HttpHandlerCache;
    });
})();
/**
@file The class definition for the dessertJS App class. The App class defines the scope of the application context as defined by the element that wraps the application.
Example of an application definition in the markup is <div dsrt-app="my-first-dsrt-app"></div>
@author Jacob Heater
*/
(function () {

    "use strict";

    define("dessert.application", [
        'dessert.module',
        'dessert.common',
        "dessert.httphandlercache"
    ], main);

    /**
     * RequireJS entry point.
     * 
     * @param {Function} $module A constructor that represents dessertJS modules.
     * @param {Object} $common A library of common dessertJS functionality.
     * @param {Function} $httpHandlerCache A constructor that represents a cache of HTTP response handlers.
     * @returns {Function} A constructor function that represents a dessertJS application.
     */
    function main($module, $common, $httpHandlerCache) {

        var emptyString = $common.utils.emptyString;
        var utils = $common.utils;

        /**
         * A constructor to build dessertJS Apps.
         * @class
         * @param {String} name The name of the app.
         * @param {Object} dsrt The dessertJS instance that will be used to init the app.
         * @param {Object} $app The jQuery object that represents your application scope.
         */
        function Application(name, dsrt, $app) {
            var modules = {};
            var componentRegistry = {};
            var tagRegistry = {};
            var elems = [];
            /**
             * The name of the app
             */
            this.name = name || "";
            /**
             * Adds a new module to the application. A module is an isolated piece of functionality
             * that contains its own MVC logic.
             * @param {String} name The name of the module to add.
             * @param {Object} globals The global variables that can be used to initialize module related pieces.
             * @returns {Object} A new instance of the Module prototype.
             */
            this.module = function (name, globals) {
                modules[name] = new $module(name, this, globals);
                return modules[name];
            };
            /**
             * Allows for getting and removing modules from the app instance.
             */
            this.modules = {
                /**
                 * Gets a module from the applications module cache.
                 * @param {String} name The name of the module to lookup.
                 * @returns {Object} The module instance corresponding to the name.
                 */
                get: function (name) {
                    return modules[name];
                },
                /**
                 * Removes a module from the application module cache.
                 * @param {String} name The name of the module to remove from the module cache.
                 * @returns {Object} The currnet instance of the modules object for chaining.
                 */
                remove: function (name) {
                    delete modules[name];
                    return this;
                },

                /**
                 * Iterates over each module in the application and calls a
                 * handler function.
                 * 
                 * @param {Function} handler The callback to call over each module.
                 * @returns {Object} The current instance of the Application.modules object.
                 */
                each: function (handler) {
                    if (utils.isFunction(handler)) {
                        Object
                            .keys(modules)
                            .forEach(function (key) {
                                handler.call(modules[key], modules[key]);
                            });
                    }

                    return this;
                }
            };
            /**
             * Uses the provided dessertJS instance to initialize the application.
             * @param {Object} args Global arguments to be used to initialize the application.
             * @returns {Object} The current instance of the App prototype for chaining.
             */
            this.init = function (done, args) {
                dsrt.init(this, done, args);
                return this;
            };
            /**
             * Uses the provided dessertJS instance to initialize the single-page application.
             * This init should only be used to init single page applications.
             * @param {Object} args Global arguments to be used to initialize the application.
             * @returns {Object} The current instance of the App prototype for chaining.
             */
            this.pageInit = function (args) {
                dsrt.pageInit(this, args);
                return this;
            };

            this.httpHandlers = {
                page: new $httpHandlerCache()
            };

            var _initalized = false;
            Object.defineProperty(this, "initialized", {
                get: function() {
                    return _initalized;
                },
                set: function(value) {
                    if (typeof value === "boolean") {
                        _initalized = value;
                    }
                }
            });

            this.components = {
                /**
                 * Register a component to this application's component registry.
                 * 
                 * @param {String} components The list of components to add to the application context.
                 * @returns {Object} The current instance of Application.
                 */
                register: function (components) {
                    if ($common.utils.isArray(components)) {
                        components.forEach(function (c) {
                            componentRegistry[c.name] = c.entry;
                        });
                    }
                    return this;
                },
                /**
                 * Gets a component url from the componentRegistry by name.
                 * 
                 * @param {String} name The name of the component.
                 * @returns {String} The url of the component.
                 */
                get: function (name) {
                    return componentRegistry[name];
                },
                /**
                 * Iterates over each components in the application
                 * componentRegistry and calls the handler function.
                 * 
                 * @param {Function} handler The function to call over each component.
                 * @returns {Object} The current instance Application.components.
                 */
                each: function (handler) {
                    var that = this;
                    if (utils.isFunction(handler)) {
                        Object
                            .keys(this.instances)
                            .forEach(function (key) {
                                handler.call(that.instances[key], that.instances[key]);
                            });
                    }

                    return this;
                },
                /**
                 * A cache of instances of component singletons.
                 */
                instances: {}
            };

            /**
             * TODO: document
             */
            this.registerTags = function (tags) {
                if ($common.utils.isArray(tags)) {
                    tags.forEach(function (t) {
                        tagRegistry[t.name] = t;
                    });
                }
            };

            /**
             * TODO: document
             */
            this.getCustomTags = function () {
                var arr = [];
                Object.keys(tagRegistry).forEach(function (k) {
                    arr.push(tagRegistry[k]);
                });
                return arr;
            };

            this.trackedElements = {
                add: function(elem) {
                    elems.push(elem);

                    return this;
                },
                destroyAll: function() {
                    elems.forEach(function(elem) {
                        elem.off().off("**");
                        elem.children().off().off("**");
                    });
                }
            };

            this.$app = $app;
        };

        Application.prototype.pathTypes = $common.pathTypes;
        Application.prototype.dsrtPath = emptyString;
        Application.prototype.templates = emptyString;
        Application.prototype.src = emptyString;
        Application.prototype.providers = {
            IDataBindingProvider: null,
            jquery: null
        };
        Application.prototype.maskLifted = function emptyMaskLifted() {};

        return Application;
    }
})();
/**
 * @file A wrapper module for making async calls, which returns the promise.
 * @author Jacob Heater
 */
(function() {
  
  "use strict";

  define("dessert.ajax", main);

  /**
   * Require entry point.
   * 
   * @returns {Object} An object that exposes ajax capabilities.
   */
  function main() {

    return {
      jquery: null,
      /**
       * Does an AJAX get and returns a promise.
       * @param {String} url The url to perform HTTP GET on.
       * @returns {Object} A promise from the AJAX call.
       */
      get: function(url) {
        return this.jquery.ajax({
          type: 'GET',
          url: url,
          cache: true,
          async: true
        });
      },
      /**
       * Does an AJAX POST and returns a promise.
       * @param {String} url The url to perform the HTTP POST on.
       * @returns {Object} A promise from the AJAX call.
       */
      post: function(url, data) {
        return this.jquery.ajax({
          type: "POST",
          url: url,
          cache: true,
          async: true,
          data: data,
          contentType: "application/json; charset=utf-8",
          dataType: "json"
        });
      }
    }
  }
})();
/**
 * @file A require.js module responsible for routing in the application.
 * @author Jacob Heater
 * @since
 */
(function () {

    "use strict";

    define("dessert.routing", [],function dessertRoutingModel() {

        var location = window.location;

        /**
         * Convert the arguments array into a dessertJS routing arguments string.
         * 
         * @param {Object[]} args The array of key value pairs to convert.
         * @returns {String} The arguments string.
         */
        function parseArgs(args) {
            var result = "";
            if (args && args.length && args.length > 0) {
                result += "/:";
                result += args.map(function argsMap(a) {
                    return a.key.concat("=").concat(escape(a.value));
                }).reduce(function argsReduce(current, next) {
                    return current.concat("&").concat(next);
                });
            }
            return result;
        };

        /**
         * Cleans any hash tags from the given path.
         * 
         * @param {String} path The path to clean.
         * @returns {String} The cleaned string.
         */
        function cleanHash(path) {
            return path.replace(/[#]+/g, '');
        }

        /**
         * Inspects the path for a hash tag and any arguments to determine if
         * this is a valid route for dessertJS routing.
         * 
         * @param {String} path The path to inspect.
         * @returns {Boolean} True of the path is a valid dessertJS route.
         */
        function hasRoute(path) {
            var routeRegex = /(#\/[\w\d\/&=:]+)/gi;
            return routeRegex.test(path);
        }

        /**
         * Insepcts the given path to determine if any arguments
         * are present in the given string.
         * 
         * @param {String} path The path to insepct for arguments.
         * @returns {Boolean} True if the path contains any routing arguments.
         */
        function hasArgs(path) {
            return (path.split('#')[1] || "").indexOf(":") > -1;
        }

        return {
            hasRoute: function routingHasRoute(path) {
                var href = path || location.href;
                return hasRoute(href);
            },
            setRoute: function routingSetRoute(path, params) {
                var href = location.href;
                if (params) {
                    path += parseArgs(params);
                }
                //This will resolve to http://host:{port}/path/:arg1=value&arg2=value
                if (hasRoute(location.href)) {
                    href = location.href.split("#")[0]; //Take the left side of the split
                }
                location.href = cleanHash(href).concat("#").concat(path);
            },
            getRoute: function routingGetRoute(path) {
                var href = path || location.href;
                var pathWithParams = href.split('#')[1] || "";
                var pathOnly = pathWithParams.split(':')[0] || "";
                var endForwardSlash = /\/$/gmi;
                if (pathOnly.match(endForwardSlash)) {
                    pathOnly = pathOnly.replace(endForwardSlash, '');
                }
                return pathOnly;
            },
            getParams: function routingGetParams(path) {
                var protocol = /[a-z]+:\/\//gmi;
                var href = path || location.href;
                if (protocol.test(href)) {
                    href = href.replace(location.protocol.concat("//").concat(location.host).concat("/"), "");
                }
                var params = [];
                var args = "";
                if (hasArgs(href)) {
                    args = href.split(":")[1]; //Get the right side, because the args will be on the right of the split.
                    params = args.split("&");
                    params = params.map(function (p) {
                        var kvp = p.split("="); //Creates a key value pair
                        return {
                            key: kvp[0] || "",
                            value: unescape(kvp[1] || "")
                        };
                    }); //Resolves to [{key: 'key', value: 'value'},...];
                }
                return params;
            },
            onRouteChange: function routingOnRouteChange(handler) {
                var $this = this;

                window.addEventListener("hashchange", function () {
                    //Handle hash change when there is truly only a hash in the url.
                    if ($this.hasRoute()) {
                        handler();
                    }
                });
            }
        };
    });

})();
define("dessert.customtag", ["dessert.common"], function dessertCustomTagModule(common) {
    "use strict";
    var attrs = common.attrs;
    var customTag = {
        /**
         * Creates a new CustomTag class instance with the given name and
         * custom tag defintion.
         * 
         * @param {String} name The name of the custom tag.
         * @param {Object} definition The definition of the custom tag that tells dessertJS
         * how to render the custom tag.
         * @returns {CustomTag} A new instance of the CustomTag class.
         */
        create: function create(name, definition) {
            return new CustomTag(name, definition);
        },
        /**
         * Defines how dessertJS should render the custom tags as dessertJS element attributes.
         * 
         * Supported tag rendering modes are:
         * 1. [dsrt-src],
         * 2. [dsrt-control]
         * 3. [dsrt-component]
         */
        types: {
            externalModule: common.attrs.src,
            control: common.attrs.control,
            component: common.attrs.component
        },
        /**
         * Initializes all of the custom tags in the application scope based on all
         * of the custom tags that were configured in the application. 
         * 
         * @param {Application} app The application to initialize the tags in.
         */
        init: function init(app) {
            var $customTags;
            var $ = null;

            if (app && app.providers) {
                if (app.providers.jquery && app.providers.jquery.fn) {
                    $ = app.providers.jquery;
                }
            }

            if (app && app.getCustomTags) {
                //If this is truly an application instance, it should have a getCustomTags function defined.
                app
                    .getCustomTags()
                    //Loop over each custom tag definition.
                    .forEach(function dessertCustomTagInitForEach(tag) {
                        //Keep a reference to the custom tags that were found using the custom tag's tag property.
                        $customTags = $(tag.tag);
                        //Iterate over each custom tag member in the view and rneder them accordingly.
                        $customTags.each(function $customTagEach() {
                            var $customTag;
                            var $customTagSwap;
                            var $customTagAttrs;
                            var swapHtml = tag.replaceWith.trim().length > 0 ? tag.replaceWith : "<div></div>";
                            var excludeAttrs = ["id"];
                            //Keep a reference to the jquery custom tag object.
                            $customTag = $(this);
                            //Create the content to swap out the custom tag with.
                            $customTagSwap = $(swapHtml);
                            //Set some attributes so dessertJS knows how to render the content.
                            $customTagSwap.attr(tag.renderAs, tag.renderAsValue);
                            switch (tag.renderAs) {
                                case attrs.component:
                                    //If it's a component, don't excluse any attrs.
                                    excludeAttrs.length = 0;
                                    break;
                                case attrs.src:
                                    break;
                                case attrs.control:
                                    //If it's a control, set the renderAs property value ot the id of the custom tag.
                                    //Controls require that they have a name, and be unique, because controls get added
                                    //to the views in a dictionary.
                                    $customTagSwap.attr(tag.renderAs, $customTag.prop("id"));
                                    break;
                                default:
                                    break;
                            }

                            //Get all of the attributes of the custom tag element.
                            $customTagAttrs = common
                                .utils
                                .getElementAttrs($customTag, excludeAttrs);

                            //Add all of the custom tag attributes to our new element. 
                            Object
                                .keys($customTagAttrs)
                                .forEach(function $customTagAttrsEach(key) {
                                    $customTagSwap.attr(key, $customTagAttrs[key]);
                                });

                            //Replace the custom tag with out new content.
                            $customTag.replaceContent($customTagSwap);
                        });
                    });
            }
        }
    };

    /**
     * A class for creating a custom html tag in dessertJS.
     * 
     * @class
     */
    function CustomTag(definition) {
        this.renderAs = common.utils.emptyString;
        this.renderAsValue = common.utils.emptyString;
        this.name = common.utils.emptyString;
        this.tag = common.utils.emptyString;
        this.replaceWith = common.utils.emptyString;

        $.extend(this, definition);
    }

    return customTag;
});
/**
 * @file A require.js module responsible for loading dessertJS modules asynchronously.
 * @author Jacob Heater
 */
(function() {

    "use strict";

    define("dessert.externalmodules.init", [
        'dessert.common',
        'dessert.ajax',
        "dessert.routing",
        "dessert.customtag"
    ], function dessertExternalModulesInitModule(
        common,
        ajax,
        $routing,
        $customTag
    ) {

        /**
         * Creates a closure that will be used for loading all dessertJS context
         * external modules asynchronously. External modules can be defined as those
         * dessertJS modules that are defined with the [dsrt-src] attribute. They may
         * or may not have functional modules that are part of their loadup. However,
         * all external modules must be loaded recursively before synchronously loading
         * dessertJS sync modules.
         * 
         * @param {Object} $context The context in which the dessertJS async loading
         * should be executed.
         * @param {Object} app The dessertJS application that the context is running in.
         * @param {Boolean} isPage Determines if the page called the external module init.
         * @returns {Function} A recursive function that loads async dessertJS modules.
         */
        return function externalModulesInit($context, app, isPage) {

            var $ = null;

            if (app && app.providers) {
                if (app.providers.jquery && app.providers.jquery.fn) {
                    $ = app.providers.jquery;
                    ajax.jquery = $;
                }
            }

            var selectors = common.selectors;
            var attrs = common.attrs;
            var utils = common.utils;
            var externalModules = isPage ? $context.find(selectors.page) : $context.find(selectors.src);
            var $exMod;
            var url;
            //TODO: Determine if we need to do any query string parsing in 
            //the external module init.
            var qStringParams; //eslint-disable-line no-unused-vars
            var cleanedPath;
            var $data;

            /**
             * Internally calls a recursive function to load dessertJS modules asynchronously.
             * This asynchronously module loading does not apply to modules that are not defined
             * with [dsrt-src] attributes. These modules with external sources need to be initiailzed
             * asynchronously first so that their module definitions can be loaded into the application
             * context.
             * 
             * @param {Function} done The function that is to be invoked when the async module loading
             * has completed.
             * @param {Function} syncModulesDone The function that is to be invoked when the synchronous
             * module loading has completed.
             * @param {Boolean} isPage Determines if the page triggered this initialization.
             */
            function processExternalModules(done, syncModulesDone) {
                /**
                 * Iterates over all of the matched selectors ([dsrt-src]) for async
                 * modules and recursively loads all of the modules.
                 */
                function processExternalModulesRecursive(i) {
                    //Get the [data-src] element at index i.
                    $exMod = externalModules.eq(i);
                    //Parse any query string params on the path.
                    qStringParams = utils.parseQueryString($exMod.attr(attrs.src));
                    //Clean the path of any characters that we're not allowing.
                    cleanedPath = utils.cleanQueryString($exMod.attr(attrs.src));
                    //Build out the URL that we're going to use for the AJAX call.
                    url = utils.cleanPath("$base$modulePath.html".replace("$base", app.src).replace("$modulePath", cleanedPath));
                    //Make sure that the url doesn't contain any undefined vars because something didn't get replaced properly.
                    if (url && !((/undefined/g).test(url))) {
                        //Let's go out and fetch the HTML for the external module.
                        ajax.get(url)
                            .done(function externalModulesInitDone(html) {
                                //We got the html back from the server, let's build it out.
                                $data = $(html);
                                //Replace the [dsrt-src] element with the newly created element from our server call.
                                //Don't replace it if this is the page element. We need to be able to find this later.
                                if ($exMod.is(selectors.page)) {
                                    $exMod.setContent($data);
                                    $exMod.removeAttr(attrs.src);
                                } else if ($exMod.attr("embed") && $exMod.attr("embed").toLowerCase() === "true") {
                                    $exMod.setContent($data);
                                    $exMod.removeAttr(attrs.src);
                                } else {
                                    $exMod.replaceContent($data);
                                }
                                $customTag.init(app);
                                //If there are any more external modules to process, let's recursively call the initialize function again.
                                if (externalModules.length) {
                                    externalModulesInit($context, app)(done, syncModulesDone);
                                }
                            }).fail(function externalModulesInitFail(xhr) {
                                //Hanlde any errors here by looking up any error handlers in the 
                                //application httpHandlers cache.
                                if ($exMod.is(selectors.page)) {
                                    //If you $exMod object is the single page element, then we need to handle that here.
                                    app
                                        .httpHandlers
                                        .page
                                        .getHandlersByStatusCode(xhr.status)
                                        .forEach(function externalModuleInitFailForEach(h) {
                                            h.handler(xhr, $routing);
                                        });
                                }
                            });
                    }
                }
                if (externalModules.length > 0) {
                    //Only begin the external module initialization if there are truly
                    //any external modules to init. Start with index 0.
                    processExternalModulesRecursive(0);
                } else {
                    /*
                    When we're done constructing all of the external modules, let's build out
                    The sync modules. Sync modules don't require any calls to the server, because
                    they rely on all of the application module, and controller configuration to
                    build out the views.
                    */
                    done(syncModulesDone);
                }
            }
            //Return the function that does the external module initialization.
            return processExternalModules;
        };
    });

})();
/**
 * @file Sets up events for the given view, and allows for custom event handling
 * in the dessertJS view context.
 * @author Jacob Heater
 */
(function() {

    "use strict";

    define("dessert.events", [], dessertEventsModule);

    function dessertEventsModule() {
        /**
         * Iterates over the eventNames array and creates a new hash table that allows for adding
         * event listeners to custom events. The events can be looked up in the view by their name.
         * 
         * @param {Object} view The dessertJS view instance to add events to.
         * @param {String[]} eventNames The list of event names to add as events.
         */
        return function dessertEventsInit(view, eventNames) {
            //Duck type eventNames to check if it's an array
            if (eventNames && eventNames.length && eventNames.concat && eventNames.shift && eventNames.splice && eventNames.pop && eventNames.map) {
                eventNames.map(function dessertEventsInitMap(n) {
                    view[n] = {
                        listeners: [],
                        //Adds a listener to the listeners stack
                        /**
                         * Adds an event listener to the current event.
                         * 
                         * @param {Function} handler The function to be invoked when
                         * the event is raised.
                         * @returns {Object} The current event for chaining.
                         */
                        addListener: function addListener(handler) {
                            if (typeof handler === 'function') {
                                this.listeners.push(handler);
                            }
                            return this;
                        },
                        /**
                         * Removes the given listener from the listener array.
                         * 
                         * @param {Function} handler The handler to remove from the array.
                         * @returns {Object} The current instance of the event for chaining.
                         */
                        removeListener: function removeListener(handler) {
                            var indexOf = this.listeners.indexOf(handler);
                            if (indexOf > -1) {
                                this.listeners.splice(indexOf, 1);
                            }
                            return this;
                        },
                        /**
                         * Triggers all of the event listeners for the current event,
                         * and supplies any arguments to the handler functions.
                         * 
                         * @returns {Object} The current event instance for chaining.
                         */
                        trigger: function trigger() {
                            for (var i = 0, len = this.listeners.length; i < len; i++) {
                                this.listeners[i].apply(null, arguments);
                            }
                            return this;
                        }
                    };
                });
            }
        };
    }

})();
(function() {

    "use strict";

    define("dessert.view", [
            "dessert.events"
        ],
        function dessertViewModule(events) {

            
            /**
             * A view in dessertJS is a self-explanatory component, it represents
             * the visual element of your application. That being said, Views are
             * comprised of Controls in the View. The Controls are elements in the View
             * marked with the Control attribute. They are compiled at the time the application
             * is loaded, and are added to a hash table by their name. So, essentially,
             * a View is a collection of Controls on the page, that can be interacted with.
             * 
             * @param {String} name The name of the view.
             * @param {Object} controller The controller that the view is associated with.
             * @param {Object} $view The jQuery object that represents the view on the page.
             */
            function View(name, controller, $view) {
                this.name = name || "";
                this.controller = controller;
                this.$view = $view;
                /**
                 * Destroys the view on the page.
                 */
                this.destroy = function destroy() {
                    this.$view.remove();
                    delete this.controller;
                    delete this.$view;
                };
                /**
                 * Wires up events using the dessert events utility.
                 * The event names are mapped to a property on the view
                 * instance with the same name, and allow for handling
                 * events with the given name.
                 * 
                 * @param {String[]} eventNames The names of the events to wire up.
                 * @returns {Object} The current instance of View for chaining.
                 */
                this.configureEvents = function configureEvents() {
                    events(this, Array.apply(null, arguments));
                    return this;
                };
                this.controls = {
                    /**
                     * Adds a control instance to the view controls hash table.
                     * 
                     * @param {Object} control The control instance to add.
                     * @returns {Object} The current instance of the controls object.
                     */
                    add: function add(control) {
                        if (control && control.dsrt) {
                            this[control.dsrt.name] = control;
                        }
                        return this;
                    },
                    /**
                     * Gets a control in the view hash table by name.
                     * 
                     * @param {String} name The name of the control to look up.
                     * @returns {Object} The control in the hash table.
                     */
                    get: function get(name) {
                        return this[name];
                    },
                    /**
                     * Removes a control by name from the hash table.
                     * 
                     * @param {String} name The name of the control to remove.
                     * @returns {Object} The current instance of the controls object.
                     */
                    remove: function remove(name) {
                        delete this[name];
                        return this;
                    }
                };
                this.controlGroups = {};
                this.components = {};
            };
            return View;
        });
})();
/**
 * @file Exposes functionality for data binding in the dessertJS framework.
 * @author Jacob Heater
 */
(function () {

    "use strict";

    define("dessert.databinding", dessertDataBindingModule);

    function dessertDataBindingModule() {
        var dessertDatabindingUtil = {
            cleanupDeferredAttrs: cleanupDeferredAttrs
        };

        var deferredAttrs = [{
            regex: /deferred-src/gmi,
            repl: "src"
        }];

        /**
         * Cleans up any deferred-* attributes from the databound template.
         * 
         * @param {String} template The databound template.
         * @param {String} The cleaned databound template.
         */
        function cleanupDeferredAttrs(template) {

            deferredAttrs.forEach(function (attr) {
                template = template.replace(attr.regex, attr.repl);
            });

            return template;
        }

        return dessertDatabindingUtil;
    }
})();
/**
@file Defines the repeat method which is defined in the dsrt.control.extensions module.
@author Jacob Heater
*/
(function() {

    "use strict";

    define("dessert.control.repeat", [
        "dessert.interfaces",
        'dessert.ajax',
        'dessert.common',
        "dessert.databinding"
    ], function dessertControlRepeatModule(interfaces, ajax, common, $dataBindingUtil) {

        var selectors = common.selectors;

        /**
         * Creates a closure and returns a function that aids in repeating
         * the given template using the data set.
         * 
         * @param {Object} element The jQuery object instance.
         * @param {Object} app The dessertJS application instance.
         * @returns {Function} A closure that is used to repeat the template.
         */
        return function dessertControlRepeatInit(element, app) {

            var $ = null;
            var databinding = null;

            if (app && app.providers) {
                if (app.providers.IDataBindingProvider && app.providers.IDataBindingProvider instanceof interfaces.IDataBindingProvider) {
                    databinding = app.providers.IDataBindingProvider;
                } 
                if (app.providers.jquery && app.providers.jquery.fn) {
                    $ = app.providers.jquery;
                    ajax.jquery = $;
                }
            }

            /**
             * Enumerates over the given sequence or data set, and injects the template
             * content into the DOM element.
             * 
             * @param {any[]} sequence The data set to enumerate over.
             * @param {Object|String} template The template to repeat into the DOM element.
             * @param {Object} config The configuration for the repeater.
             * @returns {Object} The current dessertJS control for chaining.
             */
            return function dessertControlRepeat(sequence, template, config) {
                var iterateSequence;
                var bindTemplate;
                var bindable;
                var outer;
                var $bindable;
                var $output = [];
                var $elem;
                var _config = $.extend({
                    clear: true
                }, config);
                var buildOutput = function buildOutput(output) {
                    var html = output.map(function buildOutputMap(elem) {
                        return $('<div />').append($(elem).clone()).html();
                    }).join('');
                    if (_config.clear === true) {
                        element.children().remove();
                    }
                    html = $dataBindingUtil.cleanupDeferredAttrs(html);
                    element.append(!!outer ? outer.append(html) : html);
                };
                if (sequence && sequence.length) {
                    iterateSequence = function iterateSequence(callback) {
                        for (var i = 0; i < sequence.length; i++) {
                            callback(sequence[i]);
                        }
                    };
                    bindTemplate = databinding.bindTemplateToData;
                    if (typeof template === 'string') {
                        bindable = template;
                        outer = "";
                        $bindable = $(bindable);
                        if ($bindable.find(selectors.rpt).length === 1) {
                            bindable = $bindable.find(selectors.rpt).eq(0).html();
                            $bindable.find(selectors.rpt).remove();
                            outer = $bindable;
                        }
                        iterateSequence(function iterateSequenceCallback(obj) {
                            $elem = bindTemplate(bindable, obj);
                            $output.push($elem);
                        });
                        buildOutput($output);
                    } else if (typeof template === 'object') {
                        ajax.get(template.path)
                            .then(function dessertControlRepeatGetThen(data) {
                                bindable = data;
                                outer = "";
                                $bindable = $(bindable);
                                if ($bindable.find(selectors.rpt).length === 1) {
                                    bindable = $bindable.find(selectors.rpt).eq(0).html();
                                    $bindable.find(selectors.rpt).remove();
                                    outer = $bindable;
                                }
                                iterateSequence(function internalIterateSequenceCallback(obj) {
                                    $elem = bindTemplate(bindable, obj);
                                    $output.push($elem);
                                })
                                buildOutput($output);
                            });
                    }
                }
                return this;
            }
        };
    });
})();
/**
@file Extensions of the dessertJS Control, which be nature is just a jQuery object. 
These are simply just extensions of the jQuery object, which are added to the dsrt "namespace."
@author Jacob Heater
*/
(function() {

    "use strict";

    define("dessert.control.extensions", [
        'dessert.control.repeat',
        'dessert.common',
        'dessert.ajax',
        "dessert.interfaces",
        "dessert.databinding"
    ], function dessertControlExtensionsModule(repeater, common, ajax, interfaces, $dataBindingUtil) {

        var attrs = common.attrs;
        //The $ factory element result to extend with the dsrt object.
        return function dessertControlExtensionsInit(element, app) {

            var $ = null;
            var databinding = null

            if (app && app.providers && app.providers.IDataBindingProvider && app.providers.IDataBindingProvider instanceof interfaces.IDataBindingProvider) {
                databinding = app.providers.IDataBindingProvider;
            }

            if (app && app.providers) {
                if (app.providers.IDataBindingProvider && app.providers.IDataBindingProvider instanceof interfaces.IDataBindingProvider) {
                    databinding = app.providers.IDataBindingProvider;
                }
                if (app.providers.jquery && app.providers.jquery.fn) {
                    $ = app.providers.jquery;
                    ajax.jquery = $;
                }
            }
            
            /**
             * Binds the control to the given model using event driven
             * data binding. This is unlike two-way data binding because
             * this is not dirty checking. This is synchronization with native
             * DOM events.
             * 
             * @param {Object} model The data model to bind.
             * @returns {Object} The current dsrt control instance for chaining.
             */
            element.dsrt.bind = function dessertElementBind(model) {
                if (model) {
                    //First init the control with the model value
                    element.val(model[element.attr(attrs.control)]);
                    //Then set the handler to track the changes.
                    element.on('keyup keydown change', function() {
                        //TODO: Handle different types of controls such as SELECT and RadioButton
                        model[$(this).attr(attrs.control)] = ($(this).val() || $(this).text());
                    });
                }
                return this;
            };
            /**
             * Adds an event listener to watch for any changes in the control.
             * This is a fairly comprehensive set of event listeners to listen for,
             * therefore, watchers should be pretty concise.
             * 
             * @param {Function} watcher The function to fire when the event has been raised.
             * @returns {Object} The current instance of the dsrt control for chaining.
             */
            element.dsrt.watch = function dessertElementWatch(watcher) {
                if (typeof watcher === 'function') {
                    element.on('keyup keydown change', function() {
                        watcher.call($(this));
                    });
                }
                return this;
            };
            /**
             * Bind the control to a data object.
             * 
             * @param {Object} data The data to bind the control to.
             * @returns {Object} The current instance of the control dsrt namespace.
             */
            element.dsrt.dataBind = function(data) {
                if (data) {
                    var dataBoundTemplate = databinding.bindTemplateToData(element.html(), data);
                    dataBoundTemplate = $dataBindingUtil.cleanupDeferredAttrs(dataBoundTemplate);
                    element.html(dataBoundTemplate);
                }
                return this;
            };
            /**
             * TODO: reinvestigate why this is necessary.
             */
            element.dsrt.src = function dessertElementSrc(path) {
                return {
                    path: path
                };
            };
            /**
             * Adds the native jQuery .on() method to the dsrt namespace
             * for easier chaining of dsrt methods.
             * 
             * @param {String} event The name(s) of the event(s) to listen for.
             * @param {Function} handler The function to invoke when the event has been raised.
             * @returns {Object} The current instance of the dessertJS control for chaining.
             */
            element.dsrt.on = function dessertElementOn(event, handler) {
                element.on(event, handler);
                return this;
            };
            /**
             * Gives the ability to escape out to the $.fn namespace to hook into
             * additional jQuery methods. This is convenient because it allows for
             * easier chaining between the element .dsrt namespace and the element .fn
             * namespace.
             * 
             * @type {Object}
             */
            element.dsrt.jq = element;
            /**
             * Loads a module asynchronously from the given path and executes the function
             * after the module has been loaded.
             * 
             * @param {String} path The url of the path to load asynchronously.
             * @param {Function} callback The function to invoke when the module has been loaded.
             */
            element.dsrt.load = function dessertElementLoad(path, callback) {
                var app = element.dsrt.view.controller.module.app;
                var dsrtPath = app.dsrtPath;
                require([
                    dsrtPath.concat('dsrt.context.init'),
                    dsrtPath.concat('dsrt.externalmodules.init')
                ], function(contextInit, externalInit) {
                    ajax.get(path.path)
                        .then(function(data) {
                            element.children().remove();
                            element.append(data);
                            var asyncInit = externalInit(element, app);
                            asyncInit(0, function() {
                                contextInit(element, element.dsrt.view.controller.module.app, {}, callback);
                            });
                        });
                });
            };
            /**
             * Gets the outer HTML of the provided jQuery object instance.
             * 
             * @param {Object} $elem The jQuery object instance to get the outer HTML of.
             * @returns {String} The outer HTML of the DOM element.
             */
            element.dsrt.outerHtml = function dessertElementGetOuterHtml($elem) {
                return common.utils.getOuterHtml($elem);
            };
            /**
             * Repeats the given template over the given sequence for n times
             * where n is the length of the sequence.
             * 
             * @function
             * @param {any[]} sequence The sequence or data set to enumerate.
             * @param {String|Object} template The template to repeat into the control.
             * @param {Object} config The configuration for the repeater. 
             */
            element.dsrt.repeat = repeater(element, app);
        };
    });

})();
/**
@file The dessertJS Control class is simply just a decorator that adds some dessertJS dependencies to the jQuery element that is given as the element argument.
@author Jacob Heater
*/
(function() {

    "use strict";

    define("dessert.control", ['dessert.control.extensions'], dessertControlModule);

    /**
     * RequireJS entry point.
     * 
     * @param {Function} extender The dessertJS control extender that initializes control extensions.
     * @returns {Function} 
     */
    function dessertControlModule(extender) {

        /**
         * Represents a control in dessertJS.
         * 
         * This function decorates a jQuery object with the dessertJS
         * attributes that describe this control.
         * 
         * @param {String} name The name of the control.
         * @param {Object} element The jQuery instance of the DOM element that represents the control.
         * @param {Object} view The view instance that this control is linked to.
         * @param {Object} app The dessertJS application instance.
         * @returns {Object} The decorated jQuery object instance.
         */
        function Control(name, element, view, app) {
            //This just ensures that we don't accidentally override any current instance to the dsrt object.
            /**
             * element.dsrt namespace for the dessertJS extensions of the
             * jQuery instance.
             * 
             * @type {Object}
             */
            element.dsrt = element.dsrt || {};
            /**
             * The name of the dessertJS control instance. When accessing this control
             * in the view controls hash table, you will look up the controls
             * by their names.
             * 
             * @type {String}
             */
            element.dsrt.name = name;
            /**
             * The dessertJS view that this control is associated with.
             * 
             * @type {Object}
             */
            element.dsrt.view = view;

            /**
             * Call the $.fn.remove() function.
             */
            element.destroy = function() {
                element.remove();
            };
            //Extend the dessertJS control.
            extender(element, app);
            return element;
        };

        return Control;
    }
})();
/**
 * @file A simple prototype that defines a data model.
 * @author Jacob Heater
 */
(function() {

    "use strict";

    define("dessert.model", [],function dessertModelModule() {
        //A Model is a data object for the view.
        /**
         * Defines a data model for the dessertJS MVC application.
         * 
         * @class
         * 
         * @param {Object} members The members hash table to merge into the current
         * Model instance.
         */
        function Model(members) {
            if (typeof members === 'object') {
                Object.keys(members).forEach(function modelKeysEach(key) {
                    this[key] = members[key];
                }.bind(this));
            }
        };
        return Model;
    });

})();
/**
 * @file TODO: document
 * @author Jacob Heater
 * @since 09/18/2016
 */
(function() {
    "use strict";

    define("dessert.component", ["dessert.common"], function dessertComponentModule(common) {

        /**
         * TODO: document component
         * 
         * @class
         */
        function Component() {

        }

        /**
         * Allows one prototype to extend another.
         */
        function extend(child) {
            child.prototype = Object.create(this.prototype);
            child.prototype.constructor = child;
            child.extend = extend.bind(child);
            return child;
        }

        Component.prototype.constructor = common.utils.noop;
        Component.prototype.constructor.prototype.destroy = common.utils.noop;
        Component.prototype.constructorInstances = [];
        Component.prototype.render = common.utils.noop;
        Component.prototype.instance = null;
        Component.extend = extend.bind(Component);

        return Component;
    });
})();
(function() {

    "use strict";

    var depedencies = [
        "dessert.common"
    ];

    define("dessert.asyncresource", depedencies, main);

    /**
     * Require entry point.
     * 
     * @param {Object} common The common library for dessertJS.
     */
    function main(common) {
        /**
         * A class for handling asynchronous resources in dessertJS.
         * 
         * @class
         */
        function asyncResource() {
            var _resolve = common.utils.noop;

            /**
             * Sets the function to be called when the resource .notify() function is called.
             * 
             * @param {Function} done The function to call when the resource is notified.
             * @returns {Object} The current instance of asyncResource.
             */
            this.resolve = function(done) {
                _resolve = done;
                return this;
            };

            /**
             * Notifies the asynchronous resource that the resource has finished loading.
             * 
             * @param {any} thisArg The argument to bind the .resolve() function's this context to.
             * @param {any[]} args The arguments to pass into the .resolve() function.
             * @returns {Object} The current instance of asyncResource.
             */
            this.notify = function(thisArg, args) {
                args = Array.isArray(args) ? args : [];
                if (common.utils.isFunction(_resolve)) {
                    _resolve.apply(thisArg, args);
                }
                return this;
            };
        }

        return asyncResource;
    }
})();
define("dessert.asyncresource", function(){});

/**
 * @file
 * @author Jacob Heater
 * @since
 */
(function () {

    "use strict";

    define("dessert.view.init", [
        "dessert.common",
        "dessert.view",
        "dessert.control",
        "dessert.model",
        "dessert.component",
        "dessert.asyncresource"
    ], dessertViewInitModule);

    /**
     * Require entry point.
     * 
     * TODO: define params.
     */
    function dessertViewInitModule(
        $common,
        $View,
        $Control,
        $Model,
        $Component, //eslint-disable-line no-unused-vars
        $asyncResource
    ) {
        var selectors = $common.selectors;
        var attrs = $common.attrs;

        return function dessertViewInit($controller, controller, module, $module, app, args, page, callback) { //eslint-disable-line no-unused-vars

            var $jquery = null;

            if (app && app.providers) {
                if (app.providers.jquery && app.providers.jquery.fn) {
                    $jquery = app.providers.jquery;
                }
            }

            var views;

            if ($controller) {
                //If no controller, we'll consider it a partial view.
                views = $controller.find(selectors.view);
            } else {
                //Look in the module definition for partial views.
                views = $module.find(selectors.view);
            }

            var $view;
            var components;
            var controls;
            var controlGroups;
            var ctrlGroupName;
            var $ctrlGroup;
            var view;
            var modelMembers;
            var models;
            var $model;
            var $control;
            var controlName;
            var control;
            var model;
            var dsrtController; //eslint-disable-line no-unused-vars

            //We need to go through each view and start building out the view elements.
            views.each(function () {
                //Keep a reference to the jQuery view object.
                $view = $jquery(this);
                //Bind the controller to the view
                if (controller && controller.instance && $common.utils.isFunction(controller.instance.dataBind)) {
                    var dataBoundView = controller.instance.dataBind($view.outerHtml());
                    var $dataBoundView = $jquery(dataBoundView);

                    $view.replaceContent($dataBoundView);
                    $view = $dataBoundView;
                }
                //Track the jQuery view object.
                app.trackedElements.add($view);
                //Find all of the [dsrt-control] elements housed in the view.
                controls = $view.find(selectors.control);
                //Find all of the [dsrt-component] elements housed in the view.
                components = $view.find(selectors.component);
                //Construct a new dessertJS View instance and initialize it.
                view = new $View($view.attr(attrs.view), controller, $view);
                /*
                Build out a new model for the view. Models are just dictionaries of view elements
                annotated with [dsrt-model] attributes. We'll essentially just put a key in the 
                dictionary with the model member name.
                */
                modelMembers = {};
                //Find all of the [dsrt-model] elements housed in the view.
                models = $view.find(selectors.model);
                //Find all of the [dsrt-controlGroup] elements housed in the view.
                controlGroups = $view.find(selectors.controlGroup);
                /*
                We should start with the components because this has the least impact
                on view initialization. Components are asynchronous by design. This
                makes it so that the main thread is not getting bogged down by initializing
                these components. We can go out and start building out these resources,
                and then when they're ready, we'll notify the controller that they're
                members of that they're ready to be interacted with.
                */
                components.each(function () {
                    var $component;
                    var componentName;
                    var componentId;
                    var componentEntry;
                    //Keep a reference to the component jquery object.
                    $component = $jquery(this);
                    //Track the component for destruction later.
                    app.trackedElements.add($component);
                    //Get the name of the component from the component element
                    //We're going to look it up in the dessertJS app configuration.
                    componentName = $component.attr(attrs.component);
                    //Find the component by name in the app configuration.
                    componentEntry = app.components.get(componentName);
                    //Because components require a unique name, we're goin to expect that the 
                    //component has an ID to identify it by.
                    componentId = $component.prop(attrs.id);
                    /*
                    Set the view's component member as a new instance of asyncResouce.
                    asyncResource exposes some functionality to allow us to notify the 
                    controller of when the component is interactive.
                    */
                    view.components[componentId] = new $asyncResource();
                    if (componentEntry) {
                        /*
                        If the component entry is valid, then we're going to do a require call to
                        get the component definition. The component definition should expose the necessary
                        functions that we need to render and instantiate the component definition.
                        */
                        if ($common.utils.isString(componentEntry)) {
                            if (!app.components.instances[componentEntry]) {
                                require([componentEntry], function (_component) {
                                    if (_component) {
                                        //Let's instantiate the component using its constructor function.
                                        var c = new _component();
                                        app.components.instances[componentEntry] = c;
                                        initializeComponent(c, componentId, $component);
                                    }
                                });
                            } else {
                                $common.utils.defer(function () {
                                    var c = app.components.instances[componentEntry];
                                    initializeComponent(c, componentId, $component);
                                });
                            }

                        } else if ($common.utils.isFunction(componentEntry)) {
                            /*
                            This scenario allows for users to pass functions in as the 
                            component definition, instead of relying on require to go out
                            and get the component definition, we can directly get the constructor
                            function for the component and instantiate it. This use case behaves
                            exactly the same as the scenario above, but allows for direct
                            consumption of the component constructor function.
                            */
                            $common.utils.defer(function () {
                                var c;
                                if (!app.components.instances[componentEntry.toString()]) {
                                    c = new componentEntry();
                                    app.components.instances[componentEntry.toString()] = c;
                                } else {
                                    c = app.components.instances[componentEntry.toString()];
                                }
                                initializeComponent(c, componentId, $component);
                            });
                        }
                    }
                });

                //Iterate over all of the [dsrt-model] members, and add them as modelMembers.
                models.each(function () {
                    $model = $jquery(this);
                    //Track the jQuery $model element.
                    app.trackedElements.add($model);
                    //Default all model members to an empty string.
                    modelMembers[$model.attr(attrs.control)] = $common.utils.emptyString;
                });

                //Iterate over all of the [dsrt-control] elements.
                controls.each(function () {
                    //Keep a reference to the jquery instance of the control element.
                    $control = $jquery(this);
                    app.trackedElements.add($control);
                    //Get the name of the control from the element.
                    controlName = $control.attr(attrs.control);
                    //Instantiate a new instance of the dessertJS Control class.
                    control = new $Control(controlName, $control, view, app);
                    //Add the new instance of the control to the view's controls dictionary.
                    view.controls.add(control);
                });

                //Iterate over all of the [dsrt-controlGroup] elements.
                controlGroups.each(function () {
                    //Keep a reference to the jquery object.
                    $ctrlGroup = $jquery(this);
                    app.trackedElements.add($ctrlGroup);
                    //Get the name of the control group.
                    ctrlGroupName = $ctrlGroup.attr(attrs.controlGroup);
                    /*
                    If the control group does not exist in yet, let's construct a new
                    array for hold all of the control group members in. The point of control
                    groups is to group common controls. When we want to repeat certain functionality
                    over all of the controls, we need to keep them together, and control groups allow
                    for that behvior.
                    */
                    if (!view.controlGroups[ctrlGroupName]) {
                        //Whoops, the control group doesn't exist. Create the array to group by.
                        view.controlGroups[ctrlGroupName] = [];
                    }
                    //Now we can add the control to the group.
                    view.controlGroups[ctrlGroupName].push($ctrlGroup);
                });
                //We have a model with all of its members. Create a new dessertJS Model instance.
                model = new $Model(modelMembers);
                if (controller && controller.instance) {
                    
                    var scope = {
                        view: view,
                        model: model,
                        module: module,
                        page: page
                    };
                    
                    controller.instance.scope(scope);
                    controller.instance.init();
                }
            });

            $jquery(selectors.mask).removeAttr(attrs.mask);

            if ($common.utils.isFunction(app.maskLifted)) {
                app.maskLifted();
            }

            /**
             * TODO: document this function.
             */
            function initializeComponent(c, componentId, $component) {
                var component;
                if (c && $component) {
                    /*
                    The component should have a render function that does its 
                    work to render its view. When the component view is rendered,
                    they can invoke our callback and give us the view for passing
                    it into its constructor.
                    */
                    c.render(function (componentView) {
                        //The view is rendered, and we have the view.s
                        //Replace the [dsrt-component] element with the view element.
                        $component.replaceContent(componentView);
                        //Call the component instance's constructor function that
                        //exposes the components functionality.
                        component = new c.constructor(componentView);
                        if (Array.isArray(c.constructorInstances)) {
                            //Push this instance into the instance cache.
                            c.constructorInstances.push(component);
                        }
                        /*
                        Using the asyncResouce .notify() function, we can 
                        now notify the controller that the component is 
                        interactive and give it the component as the "this"
                        arg. We'll also pass in the component as the first argument.
                        */
                        view.components[componentId].notify(component, [component]);
                    });
                }
            }
        };
    }

})();
/**
 * @file Initializes the dessertJS controllers in the application context.
 * @author Jacob Heater
 */
(function () {

    "use strict";

    define("dessert.controller.init", [
        'dessert.common',
        'dessert.view.init'
    ], function dessertControllerInitModule(common, viewInit) {

        var selectors = common.selectors;
        var attrs = common.attrs;

        /**
         * Initializes all of the dessertJS controllers in the application context.
         * Each controller has views associated with it that will be initialized.
         * This initialization is synchronous. The initialization goes through each
         * controller instance and finds all of the views associated with that controller
         * and continues to initialize through the hierarchy.
         * 
         * @param {Object} $module The jQuery instance that encapsulates the dessertJS Module.
         * @param {Object} module The dessertJS module instance.
         * @param {Object} app The dessertJS application context instance.
         * @param {any[]} args The arguments array that will be treated as global parameters for the controller.
         * @param {Object} page The single page application context that the controller is being initialized in.
         * @param {Function} callback The function that is invoked after the initialization is completed.
         */
        return function dessertControllerInit($module, module, app, args, page, callback) {
            var $ = null;
            if (app && app.providers) {
                if (app.providers.jquery && app.providers.jquery.fn) {
                    $ = app.providers.jquery;
                }
            }
            var controllers = $module.find(selectors.controller);
            var $controller;
            var controller;
            if (controllers.length > 0) {
                controllers.each(function controllersForEach() {
                    $controller = $(this);
                    if (!callback) {
                        controller = module.controllers.get($controller.attr(attrs.controller));
                        if (controller) {
                            controller.$controller = $controller;
                            if ($.isFunction(controller.onInit)) {
                                controller.onInit();
                            }
                            //Instantiate the controller using the controller's constructor function.
                            if (!(controller.instance || controller.instance instanceof controller.constructor)) {
                                controller.instance = new controller.constructor();
                            }
                            if (controller.instance.isAsync) {
                                controller.instance.ready(function () {
                                    viewInit($controller, controller, module, $module, app, args, page, callback);
                                });
                            } else {
                                viewInit($controller, controller, module, $module, app, args, page, callback);
                            }
                        }
                    }
                });
            } else {
                //Handle partial view init
                viewInit($controller, controller, module, $module, app, args, page, callback)
            }
        };
    });
})();
/**
 * @file A require.js module for defining a dessertJS Page prototype.
 * @author Jacob Heater
 * @since
 */
(function() {
    "use strict";

    define("dessert.page", ['dessert.routing'], function dessertPageModule(routing) {

        /**
         * Defines a dessertJS page prototype for singe page application modes.
         * 
         * @param {Object} app The application the page lives in.
         * @param {Objet} $page The jQuery instance that represents dsrt-page.
         * @param {Object} args The arguments that the page is initialized with.
         */
        function Page(app, $page, args) {
            this.app = app;
            this.route = function route(src, args) {
                routing.setRoute(src, args);
            };
            this.$page = $page;
            this.args = args || [];
        };

        return Page;
    });

})();
/**
 * @file A require.js module responsible for initializing dessertJS Modules.
 * @author Jacob Heater
 */
(function() {

    "use strict";

    define("dessert.module.init", [
        'dessert.controller.init',
        'dessert.common',
        'dessert.page',
        'dessert.routing'
    ], function(
        controllerInit,
        common,
        Page,
        routing
    ) {

        var selectors = common.selectors;
        var attrs = common.attrs;

        /**
         * Initializes the dessertJS application context Modules.
         * 
         * @param {Object} $context The jQuery instance to lookup dsrt-module scopes in.
         * @param {Object} app The dessert application context the initialization is running in.
         * @param {any[]} args The argument array to be passed into the controller constructor.
         * @param {Function} callback The callback to invoke when initialization is completed.
         */
        return function dessertModuleInit($context, app, args, callback) {

            var $ = null;
            
            if (app && app.providers) {
                if (app.providers.jquery && app.providers.jquery.fn) {
                    $ = app.providers.jquery;
                }
            }
            
            var page;
            var modules;
            var $page;
            var $module;
            var module;
            var views;
            var $view;

            modules = $context.find(selectors.module);

            if (modules.length === 0) {
                //Handle partial views
                views = $context.find(selectors.view);
                views.each(function viewsEach() {
                    $view = $(this);
                    $view.wrap('<div />').parent().attr(attrs.module, $view.attr(attrs.view).concat('$partial'));
                });
                modules = $context.find(selectors.module);
            }

            $page = $context.find(selectors.page).eq(0);
            
            if ($page && $page.length > 0) {
                page = new Page(app, $page, args);
                if (!routing.hasRoute()) {
                    routing.setRoute($page.attr(attrs.page), args);
                }
            }
            
            modules.each(function modulesEach() {
                $module = $(this);
                module = app.modules.get($module.attr(attrs.module));
                if (module) {
                    module.$module = $module;
                    if ($.isFunction(module.onInit)) {
                        module.onInit();
                    }
                    controllerInit($module, module, app, args, page, callback);
                }
            });
            
            if (typeof callback === "function") {
                callback(app, $context, args);
            }
        };
    });

})();
/**
@file A helper module to initialize dessertJS in any context where dessertJS components are defined. Examples of dessertJS elements that need to be initialized are elements that have a dsrt-src attribute on them.
@author Jacob Heater
*/
(function() {

    "use strict";

    define("dessert.context.init", ['dessert.module.init'], dessertContextInitModule);

    /**
     * The require entry point.
     * 
     * @param {Function} moduleInit The module initialization function that initializes all dsrt-module entities.
     * @returns {Function} A function that initializes dessertJS in a given context.
     */
    function dessertContextInitModule(moduleInit) {
        /**
         * A function that does the module initialization in dessertJS.
         * 
         * @param {Object} $context The jQuery context that the module is to be initialized in.
         * @param {Object} app The dessertJS application instance that the module belongs to.
         * @param {any[]} args The arguments array that is to be passed into the constructor.
         * @param {Function} callback A callback that is to be fired when initialization is complete.
         */
        return function dessertContextInit($context, app, args, callback, isPage) {
            moduleInit($context, app, args, callback, isPage);
        };
    }
})();
/**
 * @file
 * @author Jacob Heater
 * @since
 */
(function() {

    "use strict";

    define("dessert.syncmodules.init", [
        'dessert.context.init',
        "dessert.customtag"
    ], function(contextInit, $customTag) {
        return function dessertSyncModuleInit($context, app, args) {
            return function onExternalModulesProcessed(done) {
                $customTag.init(app);
                contextInit($context, app, args, done);
            };
        };
    });

})();
/**
 * @file A simple require.js module to invoke both async and sync module loading.
 * @author Jacob Heater
 */
(function () {

    "use strict";

    define("dessert.init", [
        'dessert.externalmodules.init',
        'dessert.syncmodules.init',
        "dessert.common"
    ], function dessertInitModule(exmod, syncmod, common) {
        return function dessertInit($app, app, args, isPage, isHash, done) {
            var $context;
            if (!app.initialized) {
                $context = $app;
                app.initialized = true;
            } else {
                if (isPage) {
                    $context = $app.find(common.selectors.page).parent();
                } else {
                    $context = $app;
                }
            }
            var externalInit = exmod($context, app, isPage);
            var syncInit = syncmod($context, app, args);
            if (isHash) {
                externalInit(function emptyInitCallback() {}, done);
            } else {
                externalInit(syncInit, done);
            }
        };
    });

})();
/**
 * @file
 * @author Jacob Heater
 * @since
 */
(function() {

    "use strict";

    define("dessert.singlepage.init", ['dessert.routing', 'dessert.common'], function singlePageInitModule(routing, common) {

        var attrs = common.attrs;

        return function dessertSinglePageInit(app, $page) {
            var path = routing.getRoute();
            var args = routing.getParams();
            if (path && args) {
                $page.attr(attrs.src, path);
                app.pageInit(args);
            } else if ($page.attr(attrs.page)) {
                var path = $page.attr(attrs.page);
                if (!routing.hasRoute(path)) {
                    path = "#".concat(path);
                }
                path = routing.getRoute(path);
                var args = routing.getParams(path);
                $page.attr(attrs.src, path);
                app.pageInit(args);
            }
        };
    });

})();
(function () {
    "use strict";

    define("dessert.jquery.extend", dessertJqueryExtensionsModule);

    function dessertJqueryExtensionsModule() {
        return function extendJQuery($) {
            $.fn.setContent = function (content) {
                return this.html("").append(content);
            };

            $.fn.replaceContent = function (content) {
                return this.replaceWith(content);
            };

            $.fn.outerHtml = function() {
                return this.get(0).outerHTML;
            };

            return $;
        };
    }
})();
/**
 * @file The dessertJS core library.
 * @author Jacob Heater
 */
(function () {

    "use strict";

    define("dessert.core", [
            "dessert.application",
            "dessert.common",
            "dessert.init",
            "dessert.singlepage.init",
            "dessert.routing",
            "dessert.customtag",
            "dessert.jquery.extend"
        ],
        function dessertCoreModule(
            Application,
            common,
            $init,
            spa,
            routing,
            $customTag,
            $jQueryExtend
        ) {

            /**
             * Holds all dessertJS App singletons for later retrieval.
             */
            var appCache = {};
            var selectors = common.selectors;
            var attrs = common.attrs;
            var utils = common.utils;
            //This is a private wrapper for our $.dsrt object
            var $dsrt = {
                /**
                 * Initializes all dessertJS [dsrt-app] scopes within the current
                 * application or view. dessertJS can be used in a single-page-application
                 * methodology, or can be used for a simple MVC framework.
                 * 
                 * @param {Application} app The application instance to initialize.
                 * @param {Function} done The callback to invoke when initialization is complete.
                 * @param {any[]} args The global arguments to be passed during initialization.
                 * @param {Boolean} isPage Indicates if the page called the init method.
                 * @param {Boolean} isHash Indicates if the hash changed event called the init method.
                 * @returns {Object} The current $dsrt instance for chaining.
                 */
                init: function init(app, done, args, isPage, isHash) {

                    var $ = null;

                    if (app && app.providers) {
                        if (app.providers.jquery && app.providers.jquery.fn) {
                            $ = app.providers.jquery;
                        }
                    }

                    var $app = $("[" + attrs.app + "=" + app.name + "]");
                    var $page = $app.find(selectors.page);

                    $jQueryExtend($);

                    $customTag.init(app);
                    if (!isPage && $page.length > 0) {
                        spa(app, $page);
                    } else {
                        $init($app, app, args, isPage, isHash, done);
                    }
                    return this;
                },
                /**
                 * Internally calls the $dsrt.init() method indicating that the page is
                 * initializing the dessertJS context.
                 */
                pageInit: function pageInit(app, args) {
                    this.init(app, null, args, true, false);
                    return this;
                },
                /**
                 * Internally calls the $dsrt.init() method indicating that the hash changed event
                 * is initializing the dessertJS context.
                 */
                hashInit: function hashInit(app, args) {
                    this.init(app, null, args, false, true);
                    return this;
                }
            };
            /**
             * Exposes the dessertJS core functionality to set up a new dessertJS
             * application context.
             */
            var dsrtModule = {
                /**
                 * Sets up a function to be invoked before the dessertJS context
                 * is initialized. This allows for some environment setup that
                 * dessertJS may be contigent upon.
                 * 
                 * @param {Function} handler The method to invoke prior to dessertJS init.
                 * @returns {Object} The dsrtModule instance for chaining.
                 */
                preinit: function preInit(handler) {
                    handler.call(this);
                    return this;
                },
                /**
                 * requires The given dependency array, and initializes the dessertJS
                 * application context. Calls the provided callback after dessertJS
                 * has been fully initialized.
                 * 
                 * @param {String[]} dependencies The list of dependencies to require.
                 * @param {Function} done The callback to invoke when dessertJS has been initialized.
                 */
                init: function init(dependencies, done) {
                    require(dependencies, function () {
                        $dsrt.init(done);
                    });
                },
                /**
                 * Creates a new dessertJS App singleton using the given name
                 * and exposes methods to prepare to initialize the app.
                 * 
                 * @param {String} name The name of the application to add to the appCache.
                 * @param {Function} onInit A function to call after the application has been initialized.
                 * @returns {Object} The newly constructed app, or the singleton from the app cache if one already exists.
                 */
                app: function app(name, onInit) {
                    var app;
                    if (!appCache[name]) {
                        app = new Application(name, $dsrt);
                        appCache[name] = app;
                    } else {
                        app = appCache[name];
                    }
                    routing.onRouteChange(function appHashChangeHandler() {
                        clearApplicationScope(app);
                        $dsrt.hashInit(app, []);
                    });
                    if (common.utils.isFunction(onInit)) {
                        onInit.call(app, app);
                    }
                    return app;
                }
            };

            function clearApplicationScope(app) {
                app.modules.each(function () {
                    this.controllers.each(function () {
                        if (this.instance && utils.isFunction(this.instance.destroy)) {
                            this.instance.destroy();
                        }
                        this.instance = null;
                    });
                });
                app.components.each(function () {
                    if (common.utils.isArray(this.constructorInstances)) {
                        this.constructorInstances.forEach(function (inst) {
                            if (inst && utils.isFunction(inst.destroy)) {
                                inst.destroy();
                                inst = null;
                            }
                        });
                        this.constructorInstances.length = 0;
                    }
                });
            }

            return dsrtModule;
        }
    );

})();
